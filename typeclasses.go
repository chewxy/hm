// Generated by: main
// TypeWriter: smallset
// Directive: +gen on TypeClass

package hm

import (
	"bytes"
	"fmt"
)

//TypeClassSet is a set of TypeClass
type TypeClassSet struct {
	s []TypeClass
}

// NewTypeClassSet creates a new set of TypeClass, given an input of any TypeClass
func NewTypeClassSet(a ...TypeClass) *TypeClassSet {
	set := new(TypeClassSet)
	for _, v := range a {
		set = set.Add(v)
	}

	return set
}

// ToSlice returns the elements of the current set as a slice
func (set *TypeClassSet) ToSlice() []TypeClass {
	return []TypeClass(set.s)
}

// ContainsALl determines if all the wanted items are already in set
func (set *TypeClassSet) ContainsAll(ws ...TypeClass) bool {
	for _, w := range ws {
		if !set.Contains(w) {
			return false
		}
	}
	return true
}

// Add adds an item into the set, and then returns a new set. If the item already exists, it returns the current set
func (set *TypeClassSet) Add(item TypeClass) *TypeClassSet {
	if set.Contains(item) {
		return set
	}
	set.s = append(set.s, item)
	return set
}

// IsSubSetOf checks if the current set is a subset of the other set.
func (set *TypeClassSet) IsSubsetOf(other *TypeClassSet) bool {
	if len(set.s) > len(other.s) {
		return false
	}

	for _, v := range set.s {
		if !other.Contains(v) {
			return false
		}
	}

	return true
}

// IsSupersetOf checks if the current set is a superset of the other set
func (set *TypeClassSet) IsSupersetOf(other *TypeClassSet) bool {
	return other.IsSubsetOf(set)
}

// Intersect performs an intersection between two sets - only items that exist in both are returned
func (set *TypeClassSet) Intersect(other *TypeClassSet) *TypeClassSet {
	switch {
	case other == nil || len(set.s) == 0 || len(other.s) == 0:
		return nil
	default:
		retVal := new(TypeClassSet)
		retVal.s = make([]TypeClass, 0)
		for _, o := range other.s {
			if set.Contains(o) {
				retVal.s = append(retVal.s, o)
			}
		}
		return retVal
	}
}

//Union joins both sets together, keeping only unique items
func (set *TypeClassSet) Union(other *TypeClassSet) *TypeClassSet {
	switch {
	case other == nil || len(set.s) == 0 && len(other.s) == 0:
		return nil
	case len(set.s) == 0 && len(other.s) > 0:
		return other
	case len(set.s) > 0 && len(other.s) == 0:
		return set
	default:
		retVal := new(TypeClassSet)
		retVal.s = make([]TypeClass, len(set.s))
		retVal.s = retVal.s[:0]
		copy(retVal.s, set.s)
		for _, o := range other.s {
			if !retVal.Contains(o) {
				retVal.s = append(retVal.s, o)
			}
		}
		return retVal
	}
}

// Difference returns a new set with items in the current set but not in the other set.
// Equivalent to  (set - other)
func (set *TypeClassSet) Difference(other *TypeClassSet) (retVal *TypeClassSet) {
	retVal = new(TypeClassSet)
	for _, v := range set.s {
		if !other.Contains(v) {
			retVal.s = append(retVal.s, v)
		}
	}
	return retVal
}

// SymmetricDifference is the set of items that is not in each either set.
func (set *TypeClassSet) SymmetricDifference(other *TypeClassSet) *TypeClassSet {
	aDiff := set.Difference(other)
	bDiff := other.Difference(set)
	return aDiff.Union(bDiff)
}

// Equals compares two sets and checks if it is the same
func (set *TypeClassSet) Equals(other *TypeClassSet) bool {
	if set == other {
		return true
	}

	if len(set.s) != len(other.s) {
		return false
	}

	for _, v := range set.s {
		if !other.Contains(v) {
			return false
		}
	}

	return true
}

// String for stuff
func (set *TypeClassSet) String() string {
	var buf bytes.Buffer
	buf.WriteString("TypeClassSet[")
	for i, v := range set.s {
		if i == len(set.s)-1 {
			fmt.Fprintf(&buf, "%v", v)
		} else {
			fmt.Fprintf(&buf, "%v, ", v)
		}
	}
	buf.WriteString("]")
	return buf.String()
}

// Contains determines if an item is in the set already
func (set *TypeClassSet) Contains(w TypeClass) bool {
	for _, v := range set.s {
		if v == w {
			return true
		}
	}
	return false
}
